using System;
using System.ComponentModel;
using System.Diagnostics;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Markup.Xaml;
using SchemaViz.Gui.ViewModels.Diagram;

namespace SchemaViz.Gui.Views;

public partial class SchemaDiagramView : UserControl
{
	private TableNodeViewModel? _draggingNode;
	private Point _dragStartPointer;
	private double _dragStartX;
	private double _dragStartY;

	private bool _isPanning;
	private Point _panStartPointer;
	private double _panStartOffsetX;
	private double _panStartOffsetY;

	private double _lastZoom = 1.0;
	private double _lastOffsetX = 0.0;
	private double _lastOffsetY = 0.0;
	private SchemaDiagramViewModel? _attachedDiagram;

	public SchemaDiagramView()
	{
		InitializeComponent();
		Loaded += OnLoaded;
		DataContextChanged += OnDataContextChanged;
	}

	private Control? DiagramViewportElement => this.FindControl<Control>("DiagramViewport");

	private Canvas? DiagramCanvasElement => this.FindControl<Canvas>("DiagramCanvas");

	private SchemaDiagramViewModel? Diagram => DataContext as SchemaDiagramViewModel;

	private void InitializeComponent()
	{
		AvaloniaXamlLoader.Load(this);
	}

	private void OnNodePointerPressed(object? sender, PointerPressedEventArgs e)
	{
		var props = e.GetCurrentPoint(this).Properties;
		if (!props.IsLeftButtonPressed)
		{
			return;
		}

		if (Diagram is null || sender is not Control control)
		{
			return;
		}

		if (control.DataContext is not TableNodeViewModel node)
		{
			return;
		}

		Diagram.SelectTable(node);
		_draggingNode = node;
		_dragStartPointer = DiagramViewportElement is { } viewport
			? e.GetPosition(viewport)
			: e.GetPosition(this);
		_dragStartX = node.X;
		_dragStartY = node.Y;
		e.Pointer.Capture(control);
		e.Handled = true;
	}

	private void OnNodePointerMoved(object? sender, PointerEventArgs e)
	{
		if (_draggingNode is null || Diagram is null)
		{
			return;
		}

		var current = DiagramViewportElement is { } viewport
			? e.GetPosition(viewport)
			: e.GetPosition(this);
		var deltaX = (current.X - _dragStartPointer.X) / Diagram.Zoom;
		var deltaY = (current.Y - _dragStartPointer.Y) / Diagram.Zoom;
		_draggingNode.X = _dragStartX + deltaX;
		_draggingNode.Y = _dragStartY + deltaY;
		e.Handled = true;
	}

	private void OnNodePointerReleased(object? sender, PointerReleasedEventArgs e)
	{
		if (_draggingNode is null)
		{
			return;
		}

		e.Pointer.Capture(null);
		_draggingNode = null;
		e.Handled = true;
	}

	private void OnNodeSizeChanged(object? sender, SizeChangedEventArgs e)
	{
		if (sender is not Control control || control.DataContext is not TableNodeViewModel node)
		{
			return;
		}

		node.Width = e.NewSize.Width;
		node.Height = e.NewSize.Height;
	}

	private void OnCanvasPointerPressed(object? sender, PointerPressedEventArgs e)
	{
		if (Diagram is null || DiagramViewportElement is null)
		{
			return;
		}

		var props = e.GetCurrentPoint(DiagramViewportElement).Properties;
		if (props.IsRightButtonPressed || props.IsMiddleButtonPressed)
		{
			_isPanning = true;
			_panStartPointer = e.GetPosition(DiagramViewportElement);
			_panStartOffsetX = Diagram.OffsetX;
			_panStartOffsetY = Diagram.OffsetY;
			e.Pointer.Capture(DiagramViewportElement);
			e.Handled = true;
			return;
		}

		if (props.IsLeftButtonPressed)
		{
			Diagram.SelectTable(null);
		}
	}

	private void OnCanvasPointerMoved(object? sender, PointerEventArgs e)
	{
		if (!_isPanning || Diagram is null || DiagramViewportElement is null || DiagramCanvasElement is null)
		{
			return;
		}

		var current = e.GetPosition(DiagramViewportElement);
		var delta = current - _panStartPointer;

		// With Scale then Translate, offset is in screen space, so pan directly
		var newOffsetX = _panStartOffsetX + delta.X;
		var newOffsetY = _panStartOffsetY + delta.Y;

		// Clamp to canvas bounds
		var clamped = ClampOffsetToBounds(newOffsetX, newOffsetY, Diagram.Zoom);
		Diagram.OffsetX = clamped.X;
		Diagram.OffsetY = clamped.Y;
		e.Handled = true;
	}

	private Point ClampOffsetToBounds(double offsetX, double offsetY, double zoom)
	{
		if (DiagramViewportElement is null || DiagramCanvasElement is null)
		{
			return new Point(offsetX, offsetY);
		}

		var viewportSize = DiagramViewportElement.Bounds;
		var canvasWidth = DiagramCanvasElement.Width;
		var canvasHeight = DiagramCanvasElement.Height;
		var canvasScreenWidth = canvasWidth * zoom;
		var canvasScreenHeight = canvasHeight * zoom;

		// With Scale then Translate: screen = world * zoom + offset
		// Viewport top-left (screen 0,0) maps to world: (0 - offset) / zoom
		// We want: (0 - offset) / zoom >= 0, so offset <= 0
		// Viewport bottom-right maps to world: (viewportSize - offset) / zoom
		// We want: (viewportSize - offset) / zoom <= canvasSize
		// So: viewportSize - offset <= canvasSize * zoom
		// So: offset >= viewportSize - canvasSize * zoom

		// Calculate valid offset range
		var minOffsetX = viewportSize.Width - canvasScreenWidth;
		var minOffsetY = viewportSize.Height - canvasScreenHeight;
		var maxOffsetX = 0.0;
		var maxOffsetY = 0.0;

		// When canvas fits: minOffset is positive (e.g., 172), maxOffset is 0
		// Range should be [0, minOffset] to allow centering
		// When canvas doesn't fit: minOffset is negative, maxOffset is 0
		// Range is [minOffset, 0] to show canvas bounds
		if (canvasScreenWidth <= viewportSize.Width && canvasScreenHeight <= viewportSize.Height)
		{
			// Canvas fits - range is [0, minOffset] to allow centering
			var resultX = Math.Max(0.0, Math.Min(minOffsetX, offsetX));
			var resultY = Math.Max(0.0, Math.Min(minOffsetY, offsetY));
			return new Point(resultX, resultY);
		}
		else
		{
			// Canvas doesn't fit - range is [minOffset, 0]
			var resultX = Math.Max(minOffsetX, Math.Min(maxOffsetX, offsetX));
			var resultY = Math.Max(minOffsetY, Math.Min(maxOffsetY, offsetY));
			return new Point(resultX, resultY);
		}
	}

	private void OnCanvasPointerReleased(object? sender, PointerReleasedEventArgs e)
	{
		if (_isPanning)
		{
			e.Pointer.Capture(null);
			_isPanning = false;
			e.Handled = true;
		}
	}

	private void OnLoaded(object? sender, RoutedEventArgs e)
	{
		if (Diagram is null)
		{
			return;
		}

		AttachToDiagram(Diagram);

		// Initialize view to center the canvas
		InitializeViewToCenter();
	}

	private void InitializeViewToCenter()
	{
		if (Diagram is null || DiagramViewportElement is null || DiagramCanvasElement is null)
		{
			return;
		}

		// Wait for layout to complete
		DiagramViewportElement.LayoutUpdated += OnViewportLayoutUpdated;
	}

	private void OnViewportLayoutUpdated(object? sender, EventArgs e)
	{
		if (Diagram is null || DiagramViewportElement is null || DiagramCanvasElement is null)
		{
			return;
		}

		// Only initialize once
		DiagramViewportElement.LayoutUpdated -= OnViewportLayoutUpdated;

		var viewportBounds = DiagramViewportElement.Bounds;
		if (viewportBounds.Width <= 0 || viewportBounds.Height <= 0)
		{
			return;
		}

		var canvasWidth = DiagramCanvasElement.Width;
		var canvasHeight = DiagramCanvasElement.Height;
		var initialZoom = Diagram.Zoom;

		// Calculate canvas size in screen space
		var canvasScreenWidth = canvasWidth * initialZoom;
		var canvasScreenHeight = canvasHeight * initialZoom;

		// Center the canvas in the viewport
		var initialOffsetX = (viewportBounds.Width - canvasScreenWidth) / 2.0;
		var initialOffsetY = (viewportBounds.Height - canvasScreenHeight) / 2.0;

		// Only set if not already initialized (avoid overwriting user's view)
		if (Math.Abs(Diagram.OffsetX) < 0.1 &&
			Math.Abs(Diagram.OffsetY) < 0.1 &&
			Math.Abs(Diagram.Zoom - 1.0) < 0.1)
		{
			Diagram.PropertyChanged -= OnDiagramPropertyChanged;
			try
			{
				Diagram.OffsetX = initialOffsetX;
				Diagram.OffsetY = initialOffsetY;
			}
			finally
			{
				Diagram.PropertyChanged += OnDiagramPropertyChanged;
			}

			_lastOffsetX = initialOffsetX;
			_lastOffsetY = initialOffsetY;
		}
	}

	private void OnDataContextChanged(object? sender, EventArgs e)
	{
		AttachToDiagram(Diagram);
	}

	private void AttachToDiagram(SchemaDiagramViewModel? diagram)
	{
		if (_attachedDiagram is not null)
		{
			_attachedDiagram.PropertyChanged -= OnDiagramPropertyChanged;
			_attachedDiagram = null;
		}

		if (diagram is null)
		{
			return;
		}

		_attachedDiagram = diagram;
		_lastZoom = diagram.Zoom;
		_lastOffsetX = diagram.OffsetX;
		_lastOffsetY = diagram.OffsetY;
		diagram.PropertyChanged += OnDiagramPropertyChanged;
	}

	private void OnDiagramPropertyChanged(object? sender, PropertyChangedEventArgs e)
	{
		if (!ReferenceEquals(sender, _attachedDiagram) || DiagramViewportElement is null)
		{
			return;
		}

		if (e.PropertyName == nameof(SchemaDiagramViewModel.Zoom))
		{
			var diagram = _attachedDiagram!;
			var newZoom = diagram.Zoom;
			var oldZoom = _lastZoom;
			if (Math.Abs(newZoom - oldZoom) < 0.0001 ||
				oldZoom <= 0 ||
				DiagramViewportElement is null ||
				DiagramCanvasElement is null)
			{
				_lastZoom = newZoom;
				_lastOffsetX = diagram.OffsetX;
				_lastOffsetY = diagram.OffsetY;
				return;
			}

			var viewportSize = DiagramViewportElement.Bounds;
			if (viewportSize.Width <= 0 || viewportSize.Height <= 0)
			{
				_lastZoom = newZoom;
				_lastOffsetX = diagram.OffsetX;
				_lastOffsetY = diagram.OffsetY;
				return;
			}

			var canvasWidth = DiagramCanvasElement.Width;
			var canvasHeight = DiagramCanvasElement.Height;
			var canvasScreenWidth = canvasWidth * newZoom;
			var canvasScreenHeight = canvasHeight * newZoom;
			var fitsInViewport =
				canvasScreenWidth <= viewportSize.Width &&
				canvasScreenHeight <= viewportSize.Height;

			// Check if at minimum zoom - if so, always center the canvas
			var isAtMinimumZoom = newZoom <= 0.16;
			double newOffsetX;
			double newOffsetY;

			if (isAtMinimumZoom && fitsInViewport)
			{
				// At minimum zoom and canvas fits - center it in viewport
				newOffsetX = (viewportSize.Width - canvasScreenWidth) / 2.0;
				newOffsetY = (viewportSize.Height - canvasScreenHeight) / 2.0;
			}
			else
			{
				// Normal zoom-to-center: keep the world point at viewport center fixed
				// Transform: screen = world * zoom + offset
				// So: world = (screen - offset) / zoom
				var viewportCenterX = viewportSize.Width / 2.0;
				var viewportCenterY = viewportSize.Height / 2.0;

				// Get the world coordinate currently at the viewport center
				var worldX = (viewportCenterX - _lastOffsetX) / oldZoom;
				var worldY = (viewportCenterY - _lastOffsetY) / oldZoom;

				// Calculate new offset to keep that same world point at the center
				newOffsetX = viewportCenterX - worldX * newZoom;
				newOffsetY = viewportCenterY - worldY * newZoom;
			}

			// Clamp to canvas bounds
			var clamped = ClampOffsetToBounds(newOffsetX, newOffsetY, newZoom);

			// Update offset
			diagram.PropertyChanged -= OnDiagramPropertyChanged;
			try
			{
				diagram.OffsetX = clamped.X;
				diagram.OffsetY = clamped.Y;
			}
			finally
			{
				diagram.PropertyChanged += OnDiagramPropertyChanged;
			}

			_lastZoom = newZoom;
			_lastOffsetX = clamped.X;
			_lastOffsetY = clamped.Y;
		}
		else if (e.PropertyName == nameof(SchemaDiagramViewModel.OffsetX) ||
				 e.PropertyName == nameof(SchemaDiagramViewModel.OffsetY))
		{
			// Clamp offset to bounds when it changes (from panning or manual setting)
			if (_attachedDiagram is not null &&
				DiagramViewportElement is not null &&
				DiagramCanvasElement is not null)
			{
				var clamped = ClampOffsetToBounds(
					_attachedDiagram.OffsetX,
					_attachedDiagram.OffsetY,
					_attachedDiagram.Zoom);

				if (Math.Abs(clamped.X - _attachedDiagram.OffsetX) > 0.01 ||
					Math.Abs(clamped.Y - _attachedDiagram.OffsetY) > 0.01)
				{
					// Offset was out of bounds, clamp it
					_attachedDiagram.PropertyChanged -= OnDiagramPropertyChanged;
					try
					{
						_attachedDiagram.OffsetX = clamped.X;
						_attachedDiagram.OffsetY = clamped.Y;
					}
					finally
					{
						_attachedDiagram.PropertyChanged += OnDiagramPropertyChanged;
					}
				}

				// Track offset changes so we have accurate values for zoom calculations
				_lastOffsetX = _attachedDiagram.OffsetX;
				_lastOffsetY = _attachedDiagram.OffsetY;
			}
		}
	}
}